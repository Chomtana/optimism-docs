---
title: Interoperability explainer
lang: en-US
description: Learn the basics of interoperability on the OP Stack.
---

import { Callout } from 'nextra/components'
import Image from 'next/image'

import { InteropCallout } from '@/components/WipCallout'

<InteropCallout />

# Interoperability explainer 

## Why do we need interoperability

It is easy for a blockchain to be certain about information it generates itself. 
Information that comes from other sources is harder to provide in a safe, decentralized, and uncensorable manner (this is called [The Oracle Problem](https://chain.link/education-hub/oracle-problem)).
We would like the Superchain to appear as a single blockchain to the lay user, which requires quick, seamless message and asset bridging.

*Interoperability* is a set of protocols and services that lets OP Stack blockchains read each others' state.
Interoperability provides the following benefits:

- 1-block latency asset movement, removing the problem of capital fragmentation leading to better capital efficiency.
- Improved experience for both users and developers.
- Secure transfer of assets, such as ETH and ERC-20 tokens, across L2s.
- Horizontal scalability for applications that need it.

## Interoperability architecture

# Interoperability architecture 

Interoperability is provided by a new service called the [OP Supervisor](./op-supervisor).
This supervisor keeps a copy of the events for all the blockchains in the interoperability cluster, and can therefore validate that cross-chain messages (which are always initiated with an event on the source cluster).

```mermaid

graph TB
  supervisor[OP Supervisor]
  subgraph mainnet[OP Mainnet]
    node1[OP Node]<-->geth1[Execution Engine]
  end
  subgraph base[Base]
    node2[OP Node]<-->geth2[Execution Engine]
  end
  subgraph l1[Ethereum L1]
    node3[Consensus Layer]<-->geth3[Execution Layer]
  end
  supervisor<-->mainnet
  supervisor<-->base  
  supervisor<-->l1
```

### How messages get from one chain to the other

```mermaid

sequenceDiagram
    participant app as Application
    participant src as Soucre Chain
    participant op-sup as OP Supervisor
    participant dst as Destination Chain
    app->>src: Transaction
    src->>op-sup: Log Event
    note over src,op-sup: Log Event = Initializing Message
    app->>dst: Transaction
    dst->>dst: Call to CrossL2Inbox to execute or verify a message.
    dst->>op-sup: Did you receive this initiating message?
    op-sup->>dst: Yes
    note left of dst: Call is successful
    dst->>dst: CrossL2Inbox emits ExecutingMessage.
    note over dst: Executing Message
```

### Safety levels

- *Unsafe* - not yet written to L1, obtained through gossip channels, ultimately based on trust in a sequencer.
- *Cross unsafe* - verified that all executing messages have legitimate initiating messages, but otherwise still unsafe.
  Treated as unsafe for most purposes.
- *Safe* - the block and all the blocks on which it depends (those with initiating mesages to which it has executing messages) have been written to L1.
- *Finalized* - the block and all the blocks on which it depends have been on L1 for long enough to make a reorg impossible.


```mermaid

flowchart LR
    classDef finalized fill:#CCC
    classDef safe fill:#8F8
    classDef unsafe fill:#F89
    subgraph I[Blocks with Initiating Messages]
    style I fill:none
      subgraph A[Chain A]
        A0[Block n]
        A1[Block n+100]
        A2[Block n+105]
        class A0 finalized
        class A1 safe
        class A2 unsafe
      end
      subgraph B[Chain B]
        B0[Block m]
        B1[Block m+3]
        class B0,B1 safe
      end
    end
    subgraph C[Chain C]
      C0[Block with executing messages]
      class C0 unsafe
    end
    A0 --> C0
    A1 --> C0
    A2 --> C0
    B0 --> C0
    B1 --> C0 
```

A block should only be written to L1 once the blocks on which it depends are all safe.



## Secure message passing
Superchain interop includes both the protocol layer message passing and the Superchain ERC20 token specification.

*   **Message passing protocol:** the initial + finalizing/executing [message](cross-chain-message) that fire events to be consumed by the chains in the [dependency set](https://specs.optimism.io/interop/dependency-set.html)
*   **SuperchainERC20 token specification**: the [SuperchainERC20](superchain-erc20) turns message passing into asset transfer between chains in the interop set. Learn more about how the SuperchainERC20 token standard enables asset interoperability in the Superchain [here](/stack/interop/assets/superchain-erc20)

This means ETH and ERC-20s can seamlessly and securely move across L2s, and intent-based protocols (i.e., bridges) can build better experiences on top of the message passing protocol.

## Low latency
Interoperability allows for horizontally scalable blockchains, a key feature of the Superchain. With Superchain interop, latency can be 1-block (~2 seconds) by optimistically accepting cross-chain messages. 

## Interop clusters
The interop protocol works via a dependency set which is configured on a per-chain basis. The dependency set defines the set of chains that a chain will accept incoming messages from. To prevent tokens from being sent to a chain that doesn't accept incoming messages, the protocol enforces that messages can only be sent to chains within its dependency set.

## Superchain interop cluster
The Superchain builds on top of the interop protocol and implements a single mesh network with complete dependencies. In this model, each blockchain in the Superchain interop cluster would have direct connections to every other blockchain, creating a fully connected mesh network. Compared to a hub and spoke model, this provides the highest level of interoperability, as any blockchain can transact directly with any other.

Each blockchain in the Superchain interop cluster shares the same security model to mitigate the weakest-link scenario. As outlined in the [Standard Rollup Charter](https://gov.optimism.io/t/season-6-standard-rollup-charter-ratification/8135#p-36758-governing-policies-11), these chains share the same L1 `ProxyAdmin` Owner. Any changes to the Superchain interop cluster must follow the standard Protocol Upgrade vote procedureâ€”the established governance process for Superchain modifications.


## New predeploys

The following predeploys have been added to enable interoperability. Predeployed smart contracts exist at predetermined addresses in the genesis state. They are similar to precompiles but instead run directly in the EVM instead of running native code outside the EVM.

### CrossL2Inbox

The `CrossL2Inbox` is the system predeploy for cross chain messaging. Anyone can trigger the execution or validation of cross chain messages, on behalf of any user.

*   **Address:** `0x4200000000000000000000000000000000000022`
*   **Specs:** [CrossL2Inbox](https://specs.optimism.io/interop/predeploys.html#crossl2inbox)

### L2ToL2CrossDomainMessenger

The `L2ToL2CrossDomainMessenger` is a higher level abstraction on top of the `CrossL2Inbox` that provides general message passing, utilized for secure transfers ERC20 tokens between L2 chains. Messages sent through the `L2ToL2CrossDomainMessenger` on the source chain receive both replay protection and domain binding, ie the executing transaction can only be valid on a single chain.

*   **Address:** `0x4200000000000000000000000000000000000023`
*   **Specs:** [L2ToL2CrossDomainMessenger](https://specs.optimism.io/interop/predeploys.html#l2tol2crossdomainmessenger)

### OptimismSuperchainERC20Factory

The `OptimismSuperchainERC20Factory` creates ERC20 contracts that implement the SuperchainERC20 standard, grants mint-burn rights to the `L2StandardBridge` (`OptimismSuperchainERC20`), and includes a remoteToken variable. These ERC20s are called `OptimismSuperchainERC20` and can be converted back and forth with `OptimismMintableERC20` tokens. The goal of the `OptimismSuperchainERC20` is to extend functionalities of the `OptimismMintableERC20` so that they are interop compatible.

*   **Address:** `0x4200000000000000000000000000000000000026`
*   **Specs:** [OptimismSuperchainERC20Factory](https://specs.optimism.io/interop/predeploys.html#optimismsuperchainerc20factory)


### BeaconContract

The `BeaconContract` predeploy gets called by the `OptimismSuperchainERC20` BeaconProxies deployed by the SuperchainERC20Factory. The Beacon Contract implements the interface defined in [EIP-1967](https://eips.ethereum.org/EIPS/eip-1967).

*   **Address:** `0x4200000000000000000000000000000000000027`
*   **Specs:** [BeaconContract](https://specs.optimism.io/interop/predeploys.html#beaconcontract)

### SuperchainERC20Bridge

The `SuperchainERC20Bridge` is an abstraction on top of the `L2toL2CrossDomainMessenger` that facilitates token bridging using interop. It has mint and burn rights over `SuperchainERC20` tokens, as described in the [token bridging spec](https://specs.optimism.io/interop/token-bridging.html).

*   **Address:** `0x4200000000000000000000000000000000000028`
*   **Specs:** [SuperchainERC20Bridge](https://specs.optimism.io/interop/predeploys.html#superchainerc20bridge)
## Considerations
Chain operators will need to run additional infrastructure to be part of the interoperable set. 
*   The Superchain-backend service, [`op-supervisor`](op-supervisor), will be a requirement for running an OP Stack chain that has interop enabled. 
`op-supervisor` is responsible for validating all cross-chain messages and will need to have an RPC configured for each chain in the dependency set. 
*   In the future, to reduce infrastructure costs, `op-supervisor` will rely on the P2P network and cryptographic schemes for validating cross-chain messages. 

<Callout type="info">
For additional considerations, join the [Interop discussion](https://github.com/ethereum-optimism/specs/discussions/128) in our specs repo.
</Callout>

## Next steps
*   Want to learn more? Read our guide on the anatomy of a [cross-chain message](cross-chain-message) or check out this [interop design video walk-thru](https://www.youtube.com/watch?v=FKc5RgjtGes).
*   Ready to get started? Use [Supersim](supersim), a local dev environment that simulates interop for testing applications against a local version of the Superchain.
*   For more info about how OP Stack interoperability works under the hood, [check out the specs](https://specs.optimism.io/interop/overview.html).

## FAQs

### What is the latency/security tradeoff?
If a sequencer does not want to trust another sequencer at all, they can choose to only accept executing messages where the initiating message has been finalized with L1 levels of security. This demonstrates the difference in latency vs speed. The L2 data must be submitted to L1 and then the L1 block containing the transaction with the L2 data must be finalized. It takes about 15 minutes for an L1 block to finalize, and higher throughput OP Stack chains like Base and OP Mainnet submit a batch about every 5 minutes. This means that it could take about 20 minutes for an L2 transaction to be considered final and be able to be trustlessly consumed by another chain. At lower latencies, the sequencer accepting the executing message takes on some amount of equivocation risk. It could be possible to build a bonding system to add economic security to prevent equivocation, but that is not in the scope of the first release.

See this [dune dashboard](https://dune.com/oplabspbc/op-stack-chains-l1-activity#submission-frequency) to see how often OP Stack chains submit batches.

<br />

<Image src="/img/op-stack/protocol/safe-unsafe.png" alt="Safe and Unsafe Security Diagram" width={700} height={500} />

### What is stopping a sequencer from censoring a cross-chain message?
There is nothing stopping a sequencer from censoring a transaction when it is sent directly to the sequencer. This does not mean the network has no censorship resistance, users can always send a deposit transaction for censorship resistance as strong as L1 guarantees. The tradeoff here is the latency, instead of being confirmed in ~2 seconds, the transaction can be confirmed at the rate of L1 block production. It may be possible to adopt something like [EIP-7547](https://eips.ethereum.org/EIPS/eip-7547) in the future to enable low latency censorship resistance.

### What is the weakest link scenario?
Without shared security, there is a risk that interacting chains could enter a conflicting state due to cross-chain interactions. If a weaker chain in the network is attacked or experiences a reorganization, it could change its state independently. This would leave the entire interop cluster in an inconsistent state, as the security of interactions across chains is only as strong as the weakest chain.

### Are callback style transactions possible?
If two blocks are being built at the same time with shared knowledge of their contents, it is possible to build blocks where a transaction calls to another chain, does compute and then a transaction calls back with the results. This requires no protocol level changes, it just requires more sophisticated block builder infrastructure.

### What is stopping a shared sequencer from including just the executing message and not the initiating message?
The protocol enforces the fact that all executing messages are valid. It does this by reorganizing out executing messages that have invalid initiating messages. Running software that does not enforce this would be non-standard behavior and would leave yourself at risk of accepting an invalid executing message and therefore running on a forked chain.

### What is the trust/verification model? Do sequencers that opt into this interop system have to trust each other fully?
Sequencers only have to trust each other, if they are accepting executing messages where the initiating message is unsafe. This is because the sequencer's ability to equivocate on unsafe data, i.e., batch submit something different from what they gossip over the p2p network. Once data is submitted to L1, it is considered final relative to the L2 and therefore there is no longer an equivocation risk.

### Is interop different between chains with non-fungible blockspace?
Chains that have non-fungible blockspace are chains that have different features - it could be that they use Plasma for data availability, a custom gas paying token or have a large execution gas limit. As long as the chain can be fault proven, it can work with Superchain interoperability. At the application layer, it is important for chains to have legibility into the type of chain that the message originated from. This ensures that applications do not accept messages from chains they consider not secure enough. See this [discussion](https://github.com/ethereum-optimism/specs/issues/121) for additional thoughts.

When it comes to chains that have different gas limits that are interoperable, it creates a set of transactions that can execute on one chain but not the other. This happens when the transaction consumes more than the gas limit of the smaller chain but less than of the bigger chain. At 2024 usages levels, these sorts of transactions are very rare. In the future, it may be the case that these transactions become more common, it will be up to the chain operators to ensure quality of service for their users.

